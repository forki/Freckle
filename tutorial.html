<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Part 1: Understanding Functional Reactive Programming
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A Functional Reactive Programming Library for FSharp"/>
    <meta name="author" content="Jannick Johnsen"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/Freckle/content/style.css" />
    <script type="text/javascript" src="/Freckle/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://github.com/jannickj/Freckle">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/Freckle/index.html">Freckle</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1><a name="Part-1-Understanding-Functional-Reactive-Programming" class="anchor" href="#Part-1-Understanding-Functional-Reactive-Programming">Part 1: Understanding Functional Reactive Programming</a></h1>
<p>Functional Reactive Programming (or short FRP), is often mired in abstract languge and theoretical functional programming lingo.
In this tutorial we will attempt to keep it simple and easy to follow.</p>
<p>To begin with lets define FRP.
In order for something to be classified as frp it must be:</p>
<ul>
<li>Composable and Declarative (i.e. functional)</li>
<li>Reactive</li>
<li>Sampling Resolution Insensitive</li>
</ul>
<p>The first two requirements are fairly easy to understand, i.e. of course it must be functional and be able to react to events occuring in the system.
However the 3. requirement <strong>Sampling Resolution Insensitive</strong>, requires that we understand what sampling resolution is.</p>
<p>In short the sampling resolution is analogous to the the span of time between each sample, in video games this is often refered to as the tick rate.</p>
<p>However let us see how this problem plays out in an actual application.
Imagine we have the following program</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
    <span onmouseout="hideTip(event, 'fs1', 20)" onmouseover="showTip(event, 'fs1', 20)" class="f">update</span> ()
</code></pre></td>
</tr>
</table>
<p>This program updates its state and nothing more, the sampling resolution of this program depends entirely on computer running it and how costly the function <code>update</code> is.
If we assume that it always takes 16 ms to execute <code>update</code> then we get a sampling resolution at</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="n">1000</span> <span class="o">/</span> <span class="n">16</span> <span class="i">ms</span> <span class="k">~</span> <span class="n">60</span> <span class="i">ticks</span> <span class="i">per</span> <span class="i">seconds</span>
</code></pre></td>
</tr>
</table>
<p>Meaning that update is called about 60 times per seconds.</p>
<p>However as is obvious there is no guarantees given that <code>update</code> will take exactly 16 ms to execute. Which might be a problem if an application needs to update at precise interval,
old programs have sometimes ignored, and thus when executed on modern computers they run extremly fast or have completely stopped functioning properly.</p>
<p>The a naive solution to account for a fixed sampling rate, would be to delay after the update. e.g.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs11', 21)" onmouseover="showTip(event, 'fs11', 21)" class="i">desiredDelay</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs6', 22)" onmouseover="showTip(event, 'fs6', 22)" class="f">time</span> <span class="n">16</span>

<span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 23)" onmouseover="showTip(event, 'fs12', 23)" class="i">startTime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 24)" onmouseover="showTip(event, 'fs5', 24)" class="f">now</span> ()
    <span onmouseout="hideTip(event, 'fs1', 25)" onmouseover="showTip(event, 'fs1', 25)" class="f">update</span> ()
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs13', 26)" onmouseover="showTip(event, 'fs13', 26)" class="i">diffTime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 27)" onmouseover="showTip(event, 'fs5', 27)" class="f">now</span> () <span class="o">-</span> <span onmouseout="hideTip(event, 'fs12', 28)" onmouseover="showTip(event, 'fs12', 28)" class="i">startTime</span>
    <span onmouseout="hideTip(event, 'fs7', 29)" onmouseover="showTip(event, 'fs7', 29)" class="f">wait</span> (<span onmouseout="hideTip(event, 'fs11', 30)" onmouseover="showTip(event, 'fs11', 30)" class="i">desiredDelay</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs13', 31)" onmouseover="showTip(event, 'fs13', 31)" class="i">diffTime</span>)
</code></pre></td>
</tr>
</table>
<p>Initially this provides us with what we required, the program operates consistently at a fixed sampling rate.
However as you can probably already observe, if for any reason at any point during the life time of the program, <code>update</code> takes longer than expected.
Meaning that <code>diffTime &gt; desiredDelay</code> i.e. requring us to wait negative, then the program will become out of sync forever.</p>
<p>If <code>diffTime &gt; desiredDelay</code> happens consistenly on average, then there is nothing we can do, from a development perspective that can be done.
This is because the resolution supported by the system is too low to support the resolution required. In the same way that if we have a picture with a high resolution, showing it on a small screen doesn't show any more details.
The resolution required and the resolution supported must always follow each other, however they need not necessarily perfectly match, which is why we must design our programs to accomondate this.</p>
<p>Otherwise If <code>diffTime &gt; desiredDelay</code> happens only on rare occasions, then on those occasions we will forever delay all feature updates.
e.g. Imagine a program simulating a car but with the expectation that an <code>updateCar</code> function is called 10 times a second, then skipping a couple of calculations can have a huge impact on the result.</p>
<p>To solve the second of the two problems let us propose the another naive solution</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 32)" onmouseover="showTip(event, 'fs12', 32)" class="i">startTime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 33)" onmouseover="showTip(event, 'fs5', 33)" class="f">now</span> ()
    <span class="k">if</span> <span class="i">lastDiff</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="k">then</span>
        <span onmouseout="hideTip(event, 'fs1', 34)" onmouseover="showTip(event, 'fs1', 34)" class="f">update</span> ()
    <span onmouseout="hideTip(event, 'fs1', 35)" onmouseover="showTip(event, 'fs1', 35)" class="f">update</span> ()
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs13', 36)" onmouseover="showTip(event, 'fs13', 36)" class="i">diffTime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 37)" onmouseover="showTip(event, 'fs5', 37)" class="f">now</span> () <span class="o">-</span> <span onmouseout="hideTip(event, 'fs12', 38)" onmouseover="showTip(event, 'fs12', 38)" class="i">startTime</span>
    <span onmouseout="hideTip(event, 'fs7', 39)" onmouseover="showTip(event, 'fs7', 39)" class="f">wait</span> (<span onmouseout="hideTip(event, 'fs11', 40)" onmouseover="showTip(event, 'fs11', 40)" class="i">desiredDelay</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs13', 41)" onmouseover="showTip(event, 'fs13', 41)" class="i">diffTime</span>)
</code></pre></td>
</tr>
</table>
<p>This solution solves the problem by calling <code>update</code> an extra time in the event it becomes out of sync.
So job done? Not quite... because depending on how long a single execution takes it might still cause update to become out of sync.</p>
<p>Imagine that <code>update</code> was for a graphical application and looked something like this:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 42)" onmouseover="showTip(event, 'fs1', 42)" class="f">update</span> () <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs14', 43)" onmouseover="showTip(event, 'fs14', 43)" class="i">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 44)" onmouseover="showTip(event, 'fs8', 44)" class="f">updateState</span>() <span class="c">//Fairly fast state update</span>
    <span onmouseout="hideTip(event, 'fs9', 45)" onmouseover="showTip(event, 'fs9', 45)" class="f">render</span> <span onmouseout="hideTip(event, 'fs14', 46)" onmouseover="showTip(event, 'fs14', 46)" class="i">state</span>              <span class="c">//Expensive graphic render function</span>
</code></pre></td>
</tr>
</table>
<p>As you might imagine rendering two times in a row doesn't change anything from an application perspective, however it is a huge drain on the resources of the cpu.
So what we in reality want is something that allows us to define that if we miss an <code>updateState</code> then we guarantee that we calculate it but if we miss a <code>render</code> then will just be skipped.</p>
<p>Before we move onto how frp would handle these problems, let's highlight one thing that has been overlooked so far.</p>
<p>Remember the <strong>Insensitive</strong> in Sampling Resolution Insensitive, thus far the proposed solutions have completely overlooked this aspect.
All we have achieved is uniform(kinda..) sampling however consider what would happen if we changed the <code>desiredDelay</code> to half its current value.
Essentially this would mean <code>update</code> is called twice as many times, or in other words the application is <strong>Sampling Resolution Sensitive</strong>.</p>
<p>On reflection if we consider all the prior problems they have all been the victim of some form of <strong>Sampling Resolution Sensitivity</strong>.
This is why <strong>Sampling Resolution Insensitivity</strong> is and must be a property of FRP.</p>
<p>So far the problems we have shown are</p>
<ol>
<li>Unpredictable Sampling</li>
<li>Single samplings causing out of sync</li>
<li>Redudant sampling</li>
<li>The root to all of these being <strong>Sampling Resolution Sensitivity</strong></li>
</ol>
<h1><a name="Part-2-Using-Freckle" class="anchor" href="#Part-2-Using-Freckle">Part 2: Using Freckle</a></h1>
<p>Now that we understand the problem of <strong>Sampling Resolution Sensitivity</strong>, let's see how code using freckle would look.</p>
<p>Lets assume we are building a simple count app, that will count and show the result in the console.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//Simple count function</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 47)" onmouseover="showTip(event, 'fs15', 47)" class="f">updateState</span> <span onmouseout="hideTip(event, 'fs16', 48)" onmouseover="showTip(event, 'fs16', 48)" class="i">s</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs16', 49)" onmouseover="showTip(event, 'fs16', 49)" class="i">s</span> <span class="o">+</span> <span class="n">1</span>

<span class="c">//Wrapping a simple print in async, might seem strange if you are used to C#.</span>
<span class="c">//However if you tried haskell&#39;s IO syntax this should feel right at home</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs17', 50)" onmouseover="showTip(event, 'fs17', 50)" class="f">render</span> <span onmouseout="hideTip(event, 'fs18', 51)" onmouseover="showTip(event, 'fs18', 51)" class="i">at</span> <span onmouseout="hideTip(event, 'fs19', 52)" onmouseover="showTip(event, 'fs19', 52)" class="i">state</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs20', 53)" onmouseover="showTip(event, 'fs20', 53)" class="i">async</span> {
        <span class="c">//is the time when render was called</span>
        <span class="k">return</span> <span onmouseout="hideTip(event, 'fs21', 54)" onmouseover="showTip(event, 'fs21', 54)" class="f">printfn</span> <span class="s">&quot;</span><span class="pf">%A</span><span class="s">: </span><span class="pf">%d</span><span class="s">&quot;</span> (<span onmouseout="hideTip(event, 'fs22', 55)" onmouseover="showTip(event, 'fs22', 55)" class="t">Time</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs23', 56)" onmouseover="showTip(event, 'fs23', 56)" class="f">toDateTime</span> <span onmouseout="hideTip(event, 'fs18', 57)" onmouseover="showTip(event, 'fs18', 57)" class="i">at</span>)<span class="o">.</span><span class="i">TimeOfDay</span> <span onmouseout="hideTip(event, 'fs19', 58)" onmouseover="showTip(event, 'fs19', 58)" class="i">state</span>
    } 

<span class="c">//The app function is our declarative description of what our application does</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 59)" onmouseover="showTip(event, 'fs24', 59)" class="f">app</span> (<span onmouseout="hideTip(event, 'fs19', 60)" onmouseover="showTip(event, 'fs19', 60)" class="i">state</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs25', 61)" onmouseover="showTip(event, 'fs25', 61)" class="t">int</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs26', 62)" onmouseover="showTip(event, 'fs26', 62)" class="t">Sample</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs27', 63)" onmouseover="showTip(event, 'fs27', 63)" class="t">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs25', 64)" onmouseover="showTip(event, 'fs25', 64)" class="t">int</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span>
    <span class="c">//sampleAsync is the same as Sample&lt;Async&lt;_&gt;&gt;</span>
    <span onmouseout="hideTip(event, 'fs28', 65)" onmouseover="showTip(event, 'fs28', 65)" class="i">sampleAsync</span> {
        <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs29', 66)" onmouseover="showTip(event, 'fs29', 66)" class="i">state&#39;</span> <span class="o">=</span> 
            <span onmouseout="hideTip(event, 'fs30', 67)" onmouseover="showTip(event, 'fs30', 67)" class="t">Feed</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs31', 68)" onmouseover="showTip(event, 'fs31', 68)" class="f">pulse</span> <span class="n">1u</span> <span class="c">//We generate a pulse at one tick per second</span>
            <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 69)" onmouseover="showTip(event, 'fs26', 69)" class="t">Sample</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 70)" onmouseover="showTip(event, 'fs32', 70)" class="f">bind</span> (<span onmouseout="hideTip(event, 'fs30', 71)" onmouseover="showTip(event, 'fs30', 71)" class="t">Feed</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs33', 72)" onmouseover="showTip(event, 'fs33', 72)" class="f">foldPast</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs16', 73)" onmouseover="showTip(event, 'fs16', 73)" class="i">s</span> _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs15', 74)" onmouseover="showTip(event, 'fs15', 74)" class="f">updateState</span> <span onmouseout="hideTip(event, 'fs16', 75)" onmouseover="showTip(event, 'fs16', 75)" class="i">s</span>) <span onmouseout="hideTip(event, 'fs19', 76)" onmouseover="showTip(event, 'fs19', 76)" class="i">state</span>) <span class="c">//Fold over all pulses generated in this sample</span>
            <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs34', 77)" onmouseover="showTip(event, 'fs34', 77)" class="t">SampleAsync</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs35', 78)" onmouseover="showTip(event, 'fs35', 78)" class="f">ofSample</span> <span class="c">//Convert our Sample&lt;int&gt; to Sample&lt;Async&lt;int&gt;&gt;</span>
        
        <span class="c">//the Upto suffix inform the sampler that if we miss a pulse then we don&#39;t care</span>
        <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs30', 79)" onmouseover="showTip(event, 'fs30', 79)" class="t">Feed</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs36', 80)" onmouseover="showTip(event, 'fs36', 80)" class="f">pulseUpto</span> <span class="n">1u</span>
            <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 81)" onmouseover="showTip(event, 'fs26', 81)" class="t">Sample</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs37', 82)" onmouseover="showTip(event, 'fs37', 82)" class="f">map</span> (<span onmouseout="hideTip(event, 'fs30', 83)" onmouseover="showTip(event, 'fs30', 83)" class="t">Feed</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs38', 84)" onmouseover="showTip(event, 'fs38', 84)" class="f">map</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs18', 85)" onmouseover="showTip(event, 'fs18', 85)" class="i">at</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs17', 86)" onmouseover="showTip(event, 'fs17', 86)" class="f">render</span> <span onmouseout="hideTip(event, 'fs18', 87)" onmouseover="showTip(event, 'fs18', 87)" class="i">at</span> <span onmouseout="hideTip(event, 'fs29', 88)" onmouseover="showTip(event, 'fs29', 88)" class="i">state&#39;</span>)) <span class="c">//Change the pulses to the render async</span>
            <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 89)" onmouseover="showTip(event, 'fs26', 89)" class="t">Sample</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 90)" onmouseover="showTip(event, 'fs32', 90)" class="f">bind</span> <span onmouseout="hideTip(event, 'fs30', 91)" onmouseover="showTip(event, 'fs30', 91)" class="t">Feed</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs39', 92)" onmouseover="showTip(event, 'fs39', 92)" class="f">plan_</span> <span class="c">//plan converts a feed of async into an async of feed </span>
                                      <span class="c">//plan_ is the same but it discards the resulting feed</span>
        <span class="k">return</span> <span onmouseout="hideTip(event, 'fs29', 93)" onmouseover="showTip(event, 'fs29', 93)" class="i">state&#39;</span>
    }
</code></pre></td>
</tr>
</table>
<p>To set a bounded resolution we simply append a delay 100ms ~ 10 ticks per second</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs40', 94)" onmouseover="showTip(event, 'fs40', 94)" class="f">boundResolutionApp</span> <span onmouseout="hideTip(event, 'fs19', 95)" onmouseover="showTip(event, 'fs19', 95)" class="i">state</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs24', 96)" onmouseover="showTip(event, 'fs24', 96)" class="f">app</span> <span onmouseout="hideTip(event, 'fs19', 97)" onmouseover="showTip(event, 'fs19', 97)" class="i">state</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs34', 98)" onmouseover="showTip(event, 'fs34', 98)" class="t">SampleAsync</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs41', 99)" onmouseover="showTip(event, 'fs41', 99)" class="f">doAsync</span> (<span onmouseout="hideTip(event, 'fs27', 100)" onmouseover="showTip(event, 'fs27', 100)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs42', 101)" onmouseover="showTip(event, 'fs42', 101)" class="f">Sleep</span> <span class="n">100</span>) 
</code></pre></td>
</tr>
</table>
<p>With this all that should be left is simply to begin sampling</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//the sampler needs a clock to meassure time, the app function and a start state in this case zero</span>
<span onmouseout="hideTip(event, 'fs26', 102)" onmouseover="showTip(event, 'fs26', 102)" class="t">Sample</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs43', 103)" onmouseover="showTip(event, 'fs43', 103)" class="f">sampleForever</span> <span onmouseout="hideTip(event, 'fs44', 104)" onmouseover="showTip(event, 'fs44', 104)" class="t">Clock</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs45', 105)" onmouseover="showTip(event, 'fs45', 105)" class="i">systemUtc</span> <span onmouseout="hideTip(event, 'fs40', 106)" onmouseover="showTip(event, 'fs40', 106)" class="f">boundResolutionApp</span> <span class="n">0</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs27', 107)" onmouseover="showTip(event, 'fs27', 107)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs46', 108)" onmouseover="showTip(event, 'fs46', 108)" class="f">RunSynchronously</span>

<span class="c">//Run 1</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">48</span><span class="o">:</span> <span class="n">1</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">49</span><span class="o">:</span> <span class="n">2</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">50</span><span class="o">:</span> <span class="n">3</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">51</span><span class="o">:</span> <span class="n">4</span>
<span class="o">..</span><span class="o">..</span>
</code></pre></td>
</tr>
</table>
<p>So far so good we see that even though we sample 10 times more times than we need our app remains consistent.</p>
<p>Question: what happens if the resolution is below our needs?
Let's see what occurs when we set the delay to 2 seconds</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs40', 109)" onmouseover="showTip(event, 'fs40', 109)" class="i">boundResolutionApp</span> <span class="i">state</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs24', 110)" onmouseover="showTip(event, 'fs24', 110)" class="i">app</span> <span class="i">state</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs34', 111)" onmouseover="showTip(event, 'fs34', 111)" class="i">SampleAsync</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs41', 112)" onmouseover="showTip(event, 'fs41', 112)" class="i">doAsync</span> (<span onmouseout="hideTip(event, 'fs27', 113)" onmouseover="showTip(event, 'fs27', 113)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs42', 114)" onmouseover="showTip(event, 'fs42', 114)" class="i">Sleep</span> <span class="n">2000</span>)

<span class="c">//Run 2</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">23</span><span class="o">:</span> <span class="n">2</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">25</span><span class="o">:</span> <span class="n">4</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">27</span><span class="o">:</span> <span class="n">6</span>
<span class="o">&gt;</span> <span class="n">00</span><span class="o">:</span><span class="n">00</span><span class="o">:</span><span class="n">29</span><span class="o">:</span> <span class="n">8</span>
<span class="o">..</span><span class="o">..</span>
</code></pre></td>
</tr>
</table>
<p>As we can see the prints (the call to our render function) only happens every other second. However our counting remains correct.
You could say that our application changed behavior duo to changing of the resolution, and thus is not <strong>Sampling Resolution Insensitive</strong>.
However this is from the app's perspective completely expected and counted for behavior, as it explicitly <code>pulseUpto</code> for the printout.
In truth the app only cares about getting a correct count, printout is a secondary concern and it is only interested in it occuring at some point.
Thus the app maintains its property of being <strong>Insensitive</strong></p>
<p>For a fun exercise try and run the code yourself!, try and see what happens if the resolution is unbounded.</p>

<div class="tip" id="fs1">val update : unit -&gt; unit<br /><br />Full name: Tutorial.update</div>
<div class="tip" id="fs2">Multiple items<br />union case Time.Time: unit -&gt; Time<br /><br />--------------------<br />type Time =<br />&#160;&#160;| Time of unit<br />&#160;&#160;static member ( - ) : &#39;a * &#39;b -&gt; Time<br /><br />Full name: Tutorial.Time</div>
<div class="tip" id="fs3">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit</div>
<div class="tip" id="fs4">val failwith : message:string -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.Operators.failwith</div>
<div class="tip" id="fs5">val now : unit -&gt; Time<br /><br />Full name: Tutorial.now</div>
<div class="tip" id="fs6">val time : &#39;a -&gt; Time<br /><br />Full name: Tutorial.time</div>
<div class="tip" id="fs7">val wait : (Time -&gt; unit)<br /><br />Full name: Tutorial.wait</div>
<div class="tip" id="fs8">val updateState : unit -&gt; unit<br /><br />Full name: Tutorial.updateState</div>
<div class="tip" id="fs9">val render : unit -&gt; unit<br /><br />Full name: Tutorial.render</div>
<div class="tip" id="fs10">namespace Freckle</div>
<div class="tip" id="fs11">val desiredDelay : Time<br /><br />Full name: Tutorial.desiredDelay</div>
<div class="tip" id="fs12">val startTime : Time</div>
<div class="tip" id="fs13">val diffTime : Time</div>
<div class="tip" id="fs14">val state : unit</div>
<div class="tip" id="fs15">val updateState : s:int -&gt; int<br /><br />Full name: Tutorial.updateState</div>
<div class="tip" id="fs16">val s : int</div>
<div class="tip" id="fs17">val render : at:Time -&gt; state:int -&gt; Async&lt;unit&gt;<br /><br />Full name: Tutorial.render</div>
<div class="tip" id="fs18">val at : Time</div>
<div class="tip" id="fs19">val state : int</div>
<div class="tip" id="fs20">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async</div>
<div class="tip" id="fs21">val printfn : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn</div>
<div class="tip" id="fs22">Multiple items<br />union case Time.Time: unit -&gt; Time<br /><br />--------------------<br />type Time =<br />&#160;&#160;{Ticks: Ticks;}<br />&#160;&#160;override ToString : unit -&gt; string<br />&#160;&#160;static member between : a:Time -&gt; b:Time -&gt; Time<br />&#160;&#160;static member maxValue : Time<br />&#160;&#160;static member origin : Time<br />&#160;&#160;static member ofDateTime : d:DateTime -&gt; Time<br />&#160;&#160;static member ofDays : days:int32 -&gt; Time<br />&#160;&#160;static member ofHours : hour:int32 -&gt; Time<br />&#160;&#160;static member ofMicroseconds : microSec:int32 -&gt; Time<br />&#160;&#160;static member ofMilliseconds : ms:int32 -&gt; Time<br />&#160;&#160;static member ofMinutes : min:int32 -&gt; Time<br />&#160;&#160;static member ofSeconds : sec:int32 -&gt; Time<br />&#160;&#160;static member ( + ) : t1:Time * t2:Time -&gt; Time<br />&#160;&#160;static member ( - ) : t1:Time * t2:Time -&gt; Time<br />&#160;&#160;static member ticks : t:Time -&gt; Ticks<br />&#160;&#160;static member time : t:Ticks -&gt; Time<br />&#160;&#160;static member toDateTime : t:Time -&gt; DateTime<br /><br />Full name: Freckle.Time</div>
<div class="tip" id="fs23">static member Time.toDateTime : t:Time -&gt; System.DateTime</div>
<div class="tip" id="fs24">val app : state:int -&gt; Sample&lt;Async&lt;int&gt;&gt;<br /><br />Full name: Tutorial.app</div>
<div class="tip" id="fs25">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs26">Multiple items<br />module Sample<br /><br />from Freckle<br /><br />--------------------<br />type Sample&lt;&#39;a&gt; = Period -&gt; &#39;a<br /><br />Full name: Freckle.Sample&lt;_&gt;</div>
<div class="tip" id="fs27">Multiple items<br />module Async<br /><br />from Freckle<br /><br />--------------------<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task -&gt; Async&lt;unit&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs28">val sampleAsync : SampleAsync.ComputationalExpression.Builder<br /><br />Full name: Freckle.ComputationExpression.sampleAsync</div>
<div class="tip" id="fs29">val state&#39; : int</div>
<div class="tip" id="fs30">Multiple items<br />union case Feed.Feed: LazyList&lt;Time * &#39;e&gt; -&gt; Feed&lt;&#39;e&gt;<br /><br />--------------------<br />module Feed<br /><br />from Freckle<br /><br />--------------------<br />type Feed&lt;&#39;e&gt; =<br />&#160;&#160;| Feed of LazyList&lt;Time * &#39;e&gt;<br />&#160;&#160;override ToString : unit -&gt; string<br /><br />Full name: Freckle.Feed&lt;_&gt;</div>
<div class="tip" id="fs31">val pulse : pulsePerSecond:uint32 -&gt; Sample&lt;Feed&lt;Time&gt;&gt;<br /><br />Full name: Freckle.Feed.pulse</div>
<div class="tip" id="fs32">val bind : f:(&#39;a -&gt; Sample&lt;&#39;b&gt;) -&gt; m:Sample&lt;&#39;a&gt; -&gt; Sample&lt;&#39;b&gt;<br /><br />Full name: Freckle.Sample.bind</div>
<div class="tip" id="fs33">val foldPast : f:(&#39;s -&gt; &#39;a -&gt; &#39;s) -&gt; state:&#39;s -&gt; fr:Feed&lt;&#39;a&gt; -&gt; Sample&lt;&#39;s&gt;<br /><br />Full name: Freckle.Feed.foldPast</div>
<div class="tip" id="fs34">module SampleAsync<br /><br />from Freckle</div>
<div class="tip" id="fs35">val ofSample : x:Sample&lt;&#39;a&gt; -&gt; Sample&lt;Async&lt;&#39;a&gt;&gt;<br /><br />Full name: Freckle.SampleAsync.ofSample</div>
<div class="tip" id="fs36">val pulseUpto : pulsePerSecond:uint32 -&gt; Sample&lt;Feed&lt;Time&gt;&gt;<br /><br />Full name: Freckle.Feed.pulseUpto</div>
<div class="tip" id="fs37">val map : f:(&#39;a -&gt; &#39;b) -&gt; sample:Sample&lt;&#39;a&gt; -&gt; Sample&lt;&#39;b&gt;<br /><br />Full name: Freckle.Sample.map</div>
<div class="tip" id="fs38">val map : f:(&#39;a -&gt; &#39;b) -&gt; fr:Feed&lt;&#39;a&gt; -&gt; Feed&lt;&#39;b&gt;<br /><br />Full name: Freckle.Feed.map</div>
<div class="tip" id="fs39">val plan_ : fr:Feed&lt;Async&lt;&#39;a&gt;&gt; -&gt; Sample&lt;Async&lt;unit&gt;&gt;<br /><br />Full name: Freckle.Feed.plan_</div>
<div class="tip" id="fs40">val boundResolutionApp : state:int -&gt; Sample&lt;Async&lt;int&gt;&gt;<br /><br />Full name: Tutorial.boundResolutionApp</div>
<div class="tip" id="fs41">val doAsync : das:Async&lt;&#39;a&gt; -&gt; sa:Sample&lt;Async&lt;&#39;b&gt;&gt; -&gt; Sample&lt;Async&lt;&#39;b&gt;&gt;<br /><br />Full name: Freckle.SampleAsync.doAsync</div>
<div class="tip" id="fs42">static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>
<div class="tip" id="fs43">val sampleForever : clock:Clock -&gt; sampler:(&#39;s -&gt; Sample&lt;Async&lt;&#39;s&gt;&gt;) -&gt; state:&#39;s -&gt; Async&lt;&#39;a&gt;<br /><br />Full name: Freckle.Sample.sampleForever</div>
<div class="tip" id="fs44">Multiple items<br />union case Clock.Clock: Async&lt;Time&gt; -&gt; Clock<br /><br />--------------------<br />module Clock<br /><br />from Freckle.Clock<br /><br />--------------------<br />module Clock<br /><br />from Freckle<br /><br />--------------------<br />type Clock = | Clock of Async&lt;Time&gt;<br /><br />Full name: Freckle.Clock.Types.Clock</div>
<div class="tip" id="fs45">val systemUtc : Clock<br /><br />Full name: Freckle.Clock.Clock.systemUtc</div>
<div class="tip" id="fs46">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:System.Threading.CancellationToken -&gt; &#39;T</div>

        </div>
        <div class="span3">
          <img src="/Freckle/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />  
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">Freckle</li>
            <li><a href="/Freckle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://nuget.org/packages/Freckle">Get Library via NuGet</a></li>
            <li><a href="http://github.com/jannickj/Freckle">Source Code on GitHub</a></li>
            <li><a href="/Freckle/license.html">License</a></li>
            <li><a href="/Freckle/release-notes.html">Release Notes</a></li>
            
            <li class="nav-header">Getting started</li>
            <li><a href="/Freckle/tutorial.html">Sample tutorial</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/Freckle/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/jannickj/Freckle"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a>
  </body>
  </html>
